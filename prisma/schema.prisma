generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL_SQLITE")
}

model article_tags {
  article_id Int
  tag_id     Int
  tags       tags     @relation(fields: [tag_id], references: [id], onDelete: Cascade, onUpdate: NoAction)
  articles   articles @relation(fields: [article_id], references: [id], onDelete: Cascade, onUpdate: NoAction)

  @@id([article_id, tag_id])
}

model article_views {
  id         Int       @id @default(autoincrement())
  article_id Int
  ip_address String?
  user_agent String?
  view_count Int       @default(0)
  created_at DateTime?
  updated_at DateTime?
  articles   articles  @relation(fields: [article_id], references: [id], onDelete: Cascade, onUpdate: NoAction)
}

model articles {
  id            Int             @id @default(autoincrement())
  title         String
  slug          String          @unique(map: "articles_slug_unique")
  content       String
  user_id       Int
  category_id   Int?
  image         String
  status        String          @default("draft")
  published_at  DateTime?
  created_at    DateTime?
  updated_at    DateTime?
  article_tags  article_tags[]
  article_views article_views[]
  categories    categories?     @relation(fields: [category_id], references: [id], onUpdate: NoAction)
  users         users           @relation(fields: [user_id], references: [id], onDelete: Cascade, onUpdate: NoAction)
  media         media[]
}

model cache {
  key        String @id
  value      String
  expiration Int
}

model cache_locks {
  key        String @id
  owner      String
  expiration Int
}

model categories {
  id         Int        @id @default(autoincrement())
  name       String
  slug       String     @unique(map: "categories_slug_unique")
  created_at DateTime?
  updated_at DateTime?
  articles   articles[]
}

model failed_jobs {
  id         Int      @id @default(autoincrement())
  uuid       String   @unique(map: "failed_jobs_uuid_unique")
  connection String
  queue      String
  payload    String
  exception  String
  failed_at  DateTime @default(now())
}

model job_batches {
  id             String  @id
  name           String
  total_jobs     Int
  pending_jobs   Int
  failed_jobs    Int
  failed_job_ids String
  options        String?
  cancelled_at   Int?
  created_at     Int
  finished_at    Int?
}

model jobs {
  id           Int    @id @default(autoincrement())
  queue        String
  payload      String
  attempts     Int
  reserved_at  Int?
  available_at Int
  created_at   Int

  @@index([queue], map: "jobs_queue_index")
}

model media {
  id         Int       @id @default(autoincrement())
  article_id Int
  file_path  String
  media_type String
  created_at DateTime?
  updated_at DateTime?
  articles   articles  @relation(fields: [article_id], references: [id], onDelete: Cascade, onUpdate: NoAction)
}

model migrations {
  id        Int    @id @default(autoincrement())
  migration String
  batch     Int
}

model model_has_permissions {
  permission_id Int
  model_type    String
  model_id      Int
  permissions   permissions @relation(fields: [permission_id], references: [id], onDelete: Cascade, onUpdate: NoAction)

  @@id([permission_id, model_id, model_type])
  @@index([model_id, model_type], map: "model_has_permissions_model_id_model_type_index")
}

model model_has_roles {
  role_id    Int
  model_type String
  model_id   Int
  roles      roles  @relation(fields: [role_id], references: [id], onDelete: Cascade, onUpdate: NoAction)

  @@id([role_id, model_id, model_type])
  @@index([model_id, model_type], map: "model_has_roles_model_id_model_type_index")
}

model password_reset_tokens {
  email      String    @id
  token      String
  created_at DateTime?
}

model permissions {
  id                    Int                     @id @default(autoincrement())
  name                  String
  guard_name            String
  created_at            DateTime?
  updated_at            DateTime?
  model_has_permissions model_has_permissions[]
  role_has_permissions  role_has_permissions[]

  @@unique([name, guard_name], map: "permissions_name_guard_name_unique")
}

model role_has_permissions {
  permission_id Int
  role_id       Int
  roles         roles       @relation(fields: [role_id], references: [id], onDelete: Cascade, onUpdate: NoAction)
  permissions   permissions @relation(fields: [permission_id], references: [id], onDelete: Cascade, onUpdate: NoAction)

  @@id([permission_id, role_id])
}

model roles {
  id                   Int                    @id @default(autoincrement())
  name                 String
  guard_name           String
  created_at           DateTime?
  updated_at           DateTime?
  model_has_roles      model_has_roles[]
  role_has_permissions role_has_permissions[]

  @@unique([name, guard_name], map: "roles_name_guard_name_unique")
}

model sessions {
  id            String  @id
  user_id       Int?
  ip_address    String?
  user_agent    String?
  payload       String
  last_activity Int

  @@index([last_activity], map: "sessions_last_activity_index")
  @@index([user_id], map: "sessions_user_id_index")
}

model tags {
  id           Int            @id @default(autoincrement())
  name         String
  slug         String         @unique(map: "tags_slug_unique")
  created_at   DateTime?
  updated_at   DateTime?
  article_tags article_tags[]
}

model users {
  id                Int        @id @default(autoincrement())
  name              String
  email             String     @unique(map: "users_email_unique")
  email_verified_at DateTime?
  password          String
  remember_token    String?
  created_at        DateTime?
  updated_at        DateTime?
  articles          articles[]
}

model user_accounts {
  uuid              String    @default(uuid())
  name              String
  email             String    @unique(map: "user_accounts_email_unique")
  email_verified_at DateTime?
  phone             String?
  nik               String?   @unique(map: "user_accounts_nik_unique")
  password          String
  avatar            String?
  remember_token    String?
  created_at        DateTime?
  updated_at        DateTime?
}
